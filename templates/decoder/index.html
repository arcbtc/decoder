{% extends "base.html" %} {% from "macros.jinja" import window_vars with context
%} {% block page %}

<div class="row q-col-gutter-md">
  <div class="col-12 col-md-7 q-gutter-y-md">
    <q-card flat>
    <q-card-section>
    <div class="row items-center no-wrap q-mb-sm">
      <div class="col">
        <strong>
          Decode Lightning
          BOLT11, LNURL, and Lightning Address
        </strong>
      </div>
    </div>
    <div class="row items-center no-wrap q-mb-sm">
      <div class="col">
        <q-form @submit="sendFormData" class="q-gutter-md">
        <q-input 
          filled 
          dense 
          clearable 
          placeholder="Enter Invoice...." 
          v-model.trim="invoice" 
          label="invoice"
          class="q-mb-md">
        </q-input>
        <q-btn unelevated color="primary" type="submit">Go</q-btn>
        </q-form>
      </div>
    </div>
    </q-card-section>
    </q-card>

    <q-card>
      <q-card-section>
        <p>
          <b>Decoded Data</b><br />
        </p>

        <div style="padding: 10px">
            <li class="" v-for="(value, key) in decoderData" :key="key">
              <div v-if="isObject(value)" style="padding:10px; word-wrap: break-word;">
                <strong>{% raw %} {{ key }} {% endraw %}:</strong>
                <ul class="nested">
                  <li v-for="(innerValue, innerKey) in value" :key="innerKey">
                    <strong> {% raw %} {{ innerKey }} {% endraw %}:</strong>{% raw %} {{ innerValue }}{% endraw %} 
                  </li>
                </ul>
              </div>
              <div v-else style="width: 100%; padding:10px; word-wrap: break-word;" >
                <strong>{% raw %} {{ key }} {% endraw %}:</strong>
                {% raw %} {{ value }} {% endraw %} 
              </div>
            </li>
        </div>

        <!-- <div>{% raw %} {{ decoderData }} {% endraw %}</div> -->

        <div>{% raw %} {{ jsonObject }} {% endraw %}</div> 

      </q-card-section>
    </q-card>
    

    <q-card> 
      <q-table
      :data="tasks"
      row-key="Key"
      flat
      dense
      >
      </q-table>
    </q-card>
  </div>

  <div class="col-12 col-md-5 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <h6 class="text-subtitle1 q-my-none">
          {{ SITE_TITLE }} Decoder extension
        </h6>
      </q-card-section>
      <q-card-section class="q-pa-none">
        <q-separator></q-separator>
        <q-list>
          {% include "decoder/_decoder.html" %}
        </q-list>
      </q-card-section>
    </q-card>
  </div>

</div>
{% endblock %} {% block scripts %} {{ window_vars(user) }}

<script>
  var someMapObject = obj => {
    obj._data = _.clone(obj)
    obj.date = Quasar.utils.date.formatDate(
      new Date(obj.time * 1000),
      'YYYY-MM-DD HH:mm'
    )
    // here you can do something with the mapped data
    return obj
  }
  new Vue({
    el: '#vue',
    mixins: [windowMixin],
    computed: {
      endpoint: function() {
        return `/decoder/api/v1/settings?usr=${this.g.user.id}`
      }
    },  
    data: function () {
      return {
        decoderData: '',
        invoice: '',
        tasks: [
        {
          Key: "field one", 
          Value: "100",           
        },
        {
          Key: "field two",
          Value: "200"
        }],
        tableData: [],
        tableColumns: [
          {
            name: 'key',
            label: 'Key',
            field: 'key'
          },
          {
            name: 'value',
            label: 'Value',
            field: 'value'
          }
        ],
        jsonObject: '',
      };
    },
    mounted() {
     // this.formatJsonToTable();
    },
    methods: {
      sendFormData() { 
        var info = this.decoderFunction({"data": this.invoice})
      },
      formatJsonToTable() {
        this.convertJsonToTable(this.jsonObject);
        console.log("tableData: ", this.tableData)
      },
      convertJsonToTable(data, parentKey = '') {
        for (const key in data) {
          if (data.hasOwnProperty(key)) {
            let value = data[key];
            if (typeof value === 'object' && value !== null) {
              // Convert Vue observed object to plain JavaScript object             
              console.log("key: ", key, "value: ", value)
            }
            if (typeof value === 'object' && !Array.isArray(value)) {
              this.convertJsonToTable(value, key);
            } else {
              this.tableData.push({
                key: parentKey ? `${parentKey}.${key}` : key,
                value: Array.isArray(value.toString()) || typeof value === 'object' ? JSON.stringify(value) : value              
              });
              console.log("Table Push: key: ", key, "value: ", value)
            }
          }
        }
        console.log("final tableData: ", this.tableData)
      },
      getLNURLData: async function(url) { 
        console.log("inside get LNURL Data")
        try {
            const response = await fetch(url)
            console.log("response.ok : ", response.ok)
            if (!response.ok) {
              throw new Error('Network response was not ok');
            } 
            const data = await response.json()
            console.log("LNURL response object: ", data)
            this.jsonObject = data
            return data
          
          } catch (error){
            console.error('There was a problem with the fetch operation:', error);
          }        
      },
      decoderFunction: async function (data) {
        LNbits.api
          .request(
            'POST', 
            '/api/v1/payments/decode' , 
            this.g.user.wallets[0].inkey,
            data
          )
          .then(response => {
            console.log("decoderFunction response: ", response.data)
            this.decoderData = response.data

            if (this.decoderData.hasOwnProperty("domain")) {
              console.log("Key 'domain' exists! Is probably a lnurl");
              let url  = this.decoderData["domain"]
              console.log("url: ", url)
              let lnurlResponse = this.getLNURLData(url)
              console.log("decoder: lnurl response: ", lnurlResponse)
           } else { 
              console.log("Key 'domain' does not exists!");
            }

            // push into a regular table, non recursive
            const responseObject = response.data;
            const arrayFromResponse = Object.entries(responseObject).map(([key, value]) => ({
              Key: key,
              Value: value.toString()
            }));            
            // console.log("array from Response", arrayFromResponse);
            this.tasks = arrayFromResponse
          })

          .catch(error => {
            LNbits.utils.notifyApiError(error) 
          })
      }, 
      isObject(val) {
        return val !== null && typeof val === 'object' && !Array.isArray(val);
      },
    },
    ///// To run on startup /////
    created: function () {
      self = this
    }
  })
</script>
{% endblock %}