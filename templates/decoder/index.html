{% extends "base.html" %} {% from "macros.jinja" import window_vars with context
%} {% block page %}

<div class="row q-col-gutter-md">
  <div class="col-12 col-md-7 q-gutter-y-md">
    <q-card flat>
    <q-card-section>
    <div class="row items-center no-wrap q-mb-sm">
      <div class="col">
        <strong>
          Decode Lightning
          BOLT11, LNURL, and Lightning Address
        </strong>
      </div>
    </div>
    <div class="row items-center no-wrap q-mb-sm">
      <div class="col">
        <q-form @submit="sendFormData" class="q-gutter-md">
        <q-input 
          filled 
          dense 
          clearable 
          placeholder="Enter Invoice, lnurl or ln address...." 
          v-model.trim="input" 
          label="input"
          class="q-mb-md">
        </q-input>
        <q-btn unelevated color="primary" type="submit">Go</q-btn>
        </q-form>
      </div>
    </div>
    </q-card-section>
    </q-card>

    <q-card>
      <q-card-section>
        <div style="padding: 10px">
            <li v-if="invoice">
              <div style="padding:10px; word-wrap: break-word;">
                <strong> Invoice:</strong>{% raw %} {{ invoice }}{% endraw %}
              </div>
            </li>
            <li v-if="lnurl">
              <div style="padding:10px; word-wrap: break-word;">
                <strong> LNURL:</strong>{% raw %} {{ lnurl }}{% endraw %}
              </div>
            </li>
            <li class="" v-for="(value, key) in decoderData" :key="key">
              <div v-if="isObject(value)" style="padding:10px; word-wrap: break-word;">
                <strong>{% raw %} {{ key }} {% endraw %}:</strong>
                <ul class="nested">
                  <li v-for="(innerValue, innerKey) in value" :key="innerKey">
                    <strong> {% raw %} {{ innerKey }} {% endraw %}:</strong>{% raw %} {{ innerValue }}{% endraw %} 

                  </li>
                </ul>
              </div>
              <div v-else style="width: 100%; padding:10px; word-wrap: break-word;" >
                <strong>{% raw %} {{ key }} {% endraw %}:</strong>
                {% raw %} {{ value }} {% endraw %} 
              </div>
            </li>
        </div>
        <!-- lnurl content -->
        <div style="padding: 10px">
          <li class="" v-for="(value, key) in lnurlData" :key="key">
            <div v-if="isObject(value)" style="padding:10px; word-wrap: break-word;">
              <strong>{% raw %} {{ key }} {% endraw %}:</strong>
              <ul class="nested">
                <li v-for="(innerValue, innerKey) in value" :key="innerKey">
                  <strong> {% raw %} {{ innerKey }} {% endraw %}:</strong>{% raw %} {{ innerValue }}{% endraw %} 
                </li>
              </ul>
            </div>
            <div v-else style="width: 100%; padding:10px; word-wrap: break-word;" >
              <strong>{% raw %} {{ key }} {% endraw %}:</strong>
              {% raw %} {{ value }} {% endraw %} 
            </div>
          </li>
      </div>
      </q-card-section>
    </q-card>

  </div>

  <div class="col-12 col-md-5 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <h6 class="text-subtitle1 q-my-none">
          {{ SITE_TITLE }} Decoder extension
        </h6>
      </q-card-section>
      <q-card-section class="q-pa-none">
        <q-separator></q-separator>
        <q-list>
          {% include "decoder/_decoder.html" %}
        </q-list>
      </q-card-section>
    </q-card>
  </div>

</div>
{% endblock %} {% block scripts %} {{ window_vars(user) }}

<script>
  new Vue({
    el: '#vue',
    mixins: [windowMixin],
    computed: {
      endpoint: function() {
        return `/decoder/api/v1/settings?usr=${this.g.user.id}`
      }
    },  
    data: function () {
      return {
        decoderData: '',
        input: '',
        invoice: '',
        lnurl: '', 
        lnaddress: '',
        lnurlData: '',
      };
    },
    mounted() {
    },
    methods: {
      sendFormData() { 
        var info = this.decoderFunction({"data": this.input})
      },
      getLNURLData: async function(url) { 
        // console.log("inside get LNURL Data")
        try {
            const response = await fetch(url)
            // console.log("response.ok : ", response.ok)
            if (!response.ok) {
              throw new Error('Network response was not ok');
            } 
            const data = await response.json()
            // console.log("LNURL response object: ", data)
            this.lnurlData = data
            return data
          
          } catch (error){
            console.error('There was a problem with the fetch operation:', error);
          }        
      },
      decoderFunction: async function (data) {
        // check if its a ln address first
        LNbits.api
          .request(
            'POST', 
            '/api/v1/payments/decode' , 
            this.g.user.wallets[0].inkey,
            data
          )
          .then(response => {
            // console.log("decoderFunction response: ", response.data)
            this.decoderData = response.data

            if (this.decoderData.hasOwnProperty("domain")) {
              // console.log("Key 'domain' exists! Is probably a lnurl");
              this.lnurl = this.input
              this.invoice = ''
              let url  = this.decoderData["domain"]
              // console.log("url: ", url)
              let lnurlResponse = this.getLNURLData(url)
              // console.log("decoder: lnurl response: ", lnurlResponse)
           } else { 
              // console.log("Key 'domain' does not exists!");
              this.invoice = this.input
              this.lnurl = ''
              this.lnurlData = ''
            } 
          })
          .catch(error => {
            LNbits.utils.notifyApiError(error) 
          })
      }, 
      isObject(val) {
        return val !== null && typeof val === 'object' && !Array.isArray(val);
      },
    },
    ///// To run on startup /////
    created: function () {
      self = this
    }
  })
</script>
{% endblock %}